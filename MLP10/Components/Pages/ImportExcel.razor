@page "/importexcel"
@using ClosedXML.Excel
@using Microsoft.EntityFrameworkCore
@using MLP10.Data
@inject IDbContextFactory<ApplicationDbContext> DbFactory
@rendermode InteractiveServer

<h3>Импорт из Excel</h3>

<label>
    Укажите файл Excel для импорта:
    <InputFile OnChange="LoadFiles" />
</label>

@if (isLoading)
{
    <p>Загрузка ...</p>
}
else
{
    <div>Импортировано апартаментов: @apartamentList.Count()</div>
    <div>Импортировано гостей: @gostList.Count()</div>
    <div>Импортировано аренд (brons): @arendaList.Count()</div>
}

@if (!string.IsNullOrEmpty(ErrorMessage))
{
    <div class="text-danger">Ошибка: @ErrorMessage</div>
}

@code {
    const int MAX_FILESIZE = 20 * 1024 * 1024; // 20 MB
    private bool isLoading = false;
    public string ErrorMessage { get; set; } = "";
    DateTime? StartTime;
    DateTime? EndTime;

    // временные коллекции
    public List<Apartament> apartamentList = new();
    public List<Gost> gostList = new();
    public List<Arenda> arendaList = new();

    private async Task LoadFiles(InputFileChangeEventArgs e)
    {
        isLoading = true;
        ErrorMessage = "";
        var browserFile = e.File;
        if (browserFile != null)
        {
            try
            {
                using var fileStream = browserFile.OpenReadStream(MAX_FILESIZE);
                var temp = Path.GetTempFileName();
                var ext = Path.GetExtension(browserFile.Name);
                var target = Path.ChangeExtension(temp, ext);
                await using (var dest = File.Create(target))
                {
                    await fileStream.CopyToAsync(dest);
                }

                StartTime = DateTime.Now;
                await GetDataTableFromExcelAsync(target);
                EndTime = DateTime.Now;

            }
            catch (Exception ex)
            {
                ErrorMessage = ex.Message;
            }
        }
        isLoading = false;
    }

    public async Task GetDataTableFromExcelAsync(string filePath)
    {
        apartamentList.Clear();
        gostList.Clear();
        arendaList.Clear();

        try
        {
            using var workbook = new XLWorkbook(filePath);

            foreach (var ws in workbook.Worksheets)
            {
                var name = ws.Name.Trim();

                if (name.Equals("Apartament", StringComparison.OrdinalIgnoreCase))
                {
                    var range = ws.RangeUsed();
                    if (range == null) continue;
                    var table = range.AsTable();
                    foreach (var row in ws.RowsUsed().Skip(1))
                    {
                        var a = new Apartament();
                        a.ApartamentId = ParseIntCell(row, table, "ApartamentId");
                        a.ApartamentNumber = ParseNullableIntCell(row, table, "ApartamentNumber");
                        a.ApartamentType = ParseStringCell(row, table, "ApartamentType");
                        a.Cost = ParseNullableIntCell(row, table, "Cost");
                        apartamentList.Add(a);
                    }
                }
                else if (name.Equals("Gost", StringComparison.OrdinalIgnoreCase))
                {
                    var range = ws.RangeUsed();
                    if (range == null) continue;
                    var table = range.AsTable();
                    foreach (var row in ws.RowsUsed().Skip(1))
                    {
                        var g = new Gost();
                        g.GostId = ParseIntCell(row, table, "GostId");
                        g.FirstName = ParseStringCell(row, table, "FirstName");
                        g.LastName = ParseStringCell(row, table, "LastName");
                        g.Birht = ParseDateCell(row, table, "Birht");
                        g.Pasport = ParseStringCell(row, table, "Pasport");
                        g.Phone = ParseStringCell(row, table, "Phone");
                        gostList.Add(g);
                    }
                }
                else if (name.Equals("Arenda", StringComparison.OrdinalIgnoreCase))
                {
                    var range = ws.RangeUsed();
                    if (range == null) continue;
                    var table = range.AsTable();
                    foreach (var row in ws.RowsUsed().Skip(1))
                    {
                        var ar = new Arenda();
                        ar.ArendaId = ParseIntCell(row, table, "ArendaId");
                        ar.ApartamentId = ParseIntCell(row, table, "ApartamentId");
                        ar.GostId = ParseIntCell(row, table, "GostId");
                        ar.DateIn = ParseDateCell(row, table, "DateIn");
                        ar.DateOut = ParseDateCell(row, table, "DateOut");
                        ar.Cost = ParseIntCell(row, table, "Cost");

                        // свяжем навигационные свойства с временными списками
                        ar.apartament = apartamentList.FirstOrDefault(x => x.ApartamentId == ar.ApartamentId);
                        ar.gost = gostList.FirstOrDefault(x => x.GostId == ar.GostId);

                        arendaList.Add(ar);
                    }
                }
            }

            // Сбросим ID перед добавлением (чтобы EF создал новые PK)
            foreach (var a in apartamentList) a.ApartamentId = 0;
            foreach (var g in gostList) g.GostId = 0;
            foreach (var ar in arendaList) ar.ArendaId = 0;

            // Сохраняем в БД в транзакции
            using var context = DbFactory.CreateDbContext();
            using var tr = await context.Database.BeginTransactionAsync();
            try
            {
                if (apartamentList.Any()) context.AddRange(apartamentList);
                if (gostList.Any()) context.AddRange(gostList);
                // arendaList уже имеют ссылки на объекты из apartamentList и gostList (в памяти),
                // но поскольку мы добавили ранее new entities, нужно убедиться, что навигации связаны
                // После SaveChanges у нас будут реальные PK — но чтобы Arenda ссылались на правильные PK,
                // установим навигации через объекты, а EF корректно обработает связи.
                if (arendaList.Any()) context.AddRange(arendaList);

                await context.SaveChangesAsync();
                await tr.CommitAsync();
            }
            catch
            {
                await tr.RollbackAsync();
                throw;
            }
        }
        catch (Exception ex)
        {
            ErrorMessage = ex.Message;
        }
    }

    // --- Маленькие парсеры для удобства ---
    private static int ParseIntCell(IXLRow row, IXLTable table, string columnName)
    {
        var colIndex = table.FindColumn(c => c.FirstCell().GetString() == columnName)?.RangeAddress.FirstAddress.ColumnNumber;
        var val = row.Cell(colIndex ?? 0).Value;
        if (val.IsBlank || string.IsNullOrWhiteSpace(val.ToString())) return 0;
        return int.Parse(val.ToString());
    }

    private static int? ParseNullableIntCell(IXLRow row, IXLTable table, string columnName)
    {
        var colIndex = table.FindColumn(c => c.FirstCell().GetString() == columnName)?.RangeAddress.FirstAddress.ColumnNumber;
        var cellVal = row.Cell(colIndex ?? 0).Value;
        if (cellVal.IsBlank || string.IsNullOrWhiteSpace(cellVal.ToString())) return null;
        return int.Parse(cellVal.ToString());
    }

    private static string? ParseStringCell(IXLRow row, IXLTable table, string columnName)
    {
        var colIndex = table.FindColumn(c => c.FirstCell().GetString() == columnName)?.RangeAddress.FirstAddress.ColumnNumber;
        return row.Cell(colIndex ?? 0).GetString();
    }

    private static DateTime ParseDateCell(IXLRow row, IXLTable table, string columnName)
    {
        var colIndex = table.FindColumn(c => c.FirstCell().GetString() == columnName)?.RangeAddress.FirstAddress.ColumnNumber;
        var cell = row.Cell(colIndex ?? 0);
        if (cell.DataType == XLDataType.DateTime)
            return cell.GetDateTime();
        if (DateTime.TryParse(cell.GetString(), out var d)) return d;
        return DateTime.MinValue;
    }
}